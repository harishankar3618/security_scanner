# scanner.py (Fixed)
#!/usr/bin/env python3
"""
Advanced Security Scanner
A modular security scanning tool for network reconnaissance and vulnerability detection
"""

import sys
import os
import argparse
import ipaddress
from datetime import datetime
from core import port_scanner, banner_grabber, web_scanner, dir_bruteforce, cve_lookup, vuln_scanner
from utils import logger, report, config

def validate_target(target):
    """Validate if target is a valid IP address or hostname"""
    try:
        ipaddress.ip_address(target)
        return True
    except ValueError:
        # Not an IP address, could be a hostname
        if len(target.split('.')) > 1:  # Simple check for domain-like format
            return True
    return False

def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(description='Advanced Security Scanner')
    parser.add_argument('target', help='Target IP address or hostname')
    parser.add_argument('-p', '--ports', help='Port range to scan (e.g., 1-1000)', default='1-1000')
    parser.add_argument('-t', '--threads', type=int, help='Number of threads to use', default=10)
    parser.add_argument('-o', '--output', help='Output format (json, html)', default='json')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--skip-web', action='store_true', help='Skip web scanning')
    parser.add_argument('--skip-dirs', action='store_true', help='Skip directory bruteforcing')
    parser.add_argument('--wordlist', help='Custom wordlist for directory bruteforcing')
    parser.add_argument('--timeout', type=float, help='Connection timeout in seconds', default=1.0)
    
    return parser.parse_args()

def parse_port_range(port_range):
    """Parse port range string (e.g., '1-1000,3000,8000-8100')"""
    ports = []
    for part in port_range.split(','):
        if '-' in part:
            start, end = map(int, part.split('-'))
            ports.extend(range(start, end + 1))
        else:
            ports.append(int(part))
    return ports

def main():
    """Main function"""
    args = parse_arguments()
    
    # Configure logger
    log = logger.Logger(verbose=args.verbose)
    log.info(f"Advanced Security Scanner started at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    # Validate target
    if not validate_target(args.target):
        log.error(f"Invalid target: {args.target}")
        sys.exit(1)
    
    target = args.target
    log.info(f"Target: {target}")
    
    # Parse port range
    try:
        ports = parse_port_range(args.ports)
        log.info(f"Scanning {len(ports)} ports")
    except ValueError:
        log.error(f"Invalid port range: {args.ports}")
        sys.exit(1)
    
    # Create scanner configuration
    scan_config = {
        'threads': args.threads,
        'timeout': args.timeout,
        'wordlist': args.wordlist
    }
    
    # Run port scan
    log.info("Starting port scan...")
    open_ports = port_scanner.scan_ports(target, ports, threads=args.threads, timeout=args.timeout)
    log.info(f"Found {len(open_ports)} open ports")
    
    # Skip the rest if no open ports found
    if not open_ports:
        log.warning("No open ports found. Exiting.")
        sys.exit(0)
    
    # Grab service banners
    log.info("Grabbing service banners...")
    banners = banner_grabber.grab_banners(target, open_ports, timeout=args.timeout)
    
    # Initialize results dictionary
    results = {
        'target': target,
        'timestamp': datetime.now().isoformat(),
        'open_ports': open_ports,
        'service_banners': banners,
        'web_findings': [],
        'directories': [],
        'vulnerabilities': []
    }
    
    # Check for web servers
    # FIX: Get the banner string correctly from the dictionary structure
    web_ports = [p for p in open_ports if p in [80, 443, 8080, 8443] or 
                 'HTTP' in banners.get(p, {}).get('banner', '').upper()]
    
    # Web scanning
    if web_ports and not args.skip_web:
        log.info(f"Found {len(web_ports)} potential web servers. Starting web scan...")
        for port in web_ports:
            # FIX: Get the banner string correctly from the dictionary structure
            protocol = 'https' if port in [443, 8443] or 'SSL' in banners.get(port, {}).get('banner', '').upper() else 'http'
            web_url = f"{protocol}://{target}:{port}"
            log.info(f"Scanning web server at {web_url}")
            
            # Run web vulnerability scan
            web_findings = web_scanner.scan_web(web_url, timeout=args.timeout)
            results['web_findings'].extend(web_findings)
            
            # Run directory bruteforce if not skipped
            if not args.skip_dirs:
                log.info(f"Starting directory bruteforce on {web_url}")
                directories = dir_bruteforce.bruteforce(web_url, 
                                                      wordlist=args.wordlist,
                                                      threads=args.threads,
                                                      timeout=args.timeout)
                results['directories'].extend(directories)
    
    # Look up CVEs based on banners
    log.info("Looking up CVEs based on service banners...")
    cves = cve_lookup.lookup(banners)
    results['cve_matches'] = cves
    
    # Run vulnerability scanner for known services
    log.info("Checking for common vulnerabilities...")
    vulns = vuln_scanner.scan_vulnerabilities(target, open_ports, banners, timeout=args.timeout)
    results['vulnerabilities'] = vulns
    
    # Generate report
    log.info("Generating report...")
    report_file = report.generate_report(results, format=args.output)
    log.info(f"Report saved as {report_file}")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nScan aborted by user")
        sys.exit(0)
    except Exception as e:
        print(f"An error occurred: {e}")
        sys.exit(1)

#core/banner_grabber.pyimport re
import logging
import socket
import concurrent.futures

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

def identify_service(port, banner):
    """
    Identify service and version based on banner and port
    
    Args:
        port (int): Port number
        banner (str): Service banner
        
    Returns:
        dict: Service and version information
    """
    result = {'service': 'unknown', 'version': None}
    
    # Common service patterns
    patterns = {
        'ssh': (r'SSH-(\d+\.\d+).*?', r'SSH-\d+\.\d+-([^\s]+)'),
        'http': (r'HTTP/(\d+\.\d+)', r'Server: ([^\r\n]+)'),
        'ftp': (r'FTP|FileZilla|ProFTPD|vsftpd', r'([^\s]+) FTP|ProFTPD ([^\s]+)|FileZilla Server ([^\s]+)|vsftpd ([^\s]+)'),
        'smtp': (r'SMTP|Postfix|Exim|Sendmail', r'([^\s]+) ESMTP|ESMTP ([^\s]+)|Postfix ([^\s]+)|Exim ([^\s]+)|Sendmail ([^\s]+)'),
        'mysql': (r'MySQL', r'MySQL v([^\s]+)'),
        'postgresql': (r'PostgreSQL', r'PostgreSQL ([^\s]+)'),
        'rdp': (r'RDP', None),
        'vnc': (r'VNC|RFB', r'RFB (\d+\.\d+)'),
        'telnet': (r'telnet', None)
    }
    
    # Default service based on common ports
    default_services = {
        21: 'ftp',
        22: 'ssh',
        23: 'telnet',
        25: 'smtp',
        53: 'dns',
        80: 'http',
        110: 'pop3',
        143: 'imap',
        443: 'https',
        445: 'smb',
        3306: 'mysql',
        3389: 'rdp',
        5432: 'postgresql',
        5900: 'vnc',
        6379: 'redis',
        8080: 'http-alt',
        8443: 'https-alt',
        9200: 'elasticsearch',
        27017: 'mongodb'
    }
    
    # First try to identify by banner
    for service, (service_pattern, version_pattern) in patterns.items():
        if service_pattern and re.search(service_pattern, banner, re.IGNORECASE):
            result['service'] = service
            if version_pattern:
                version_match = re.search(version_pattern, banner, re.IGNORECASE)
                if version_match:
                    # Use the first non-None group
                    for group in version_match.groups():
                        if group:
                            result['version'] = group
                            break
            break
    
    # If not identified, use default service based on port
    if result['service'] == 'unknown' and port in default_services:
        result['service'] = default_services[port]
    
    return result
def grab_banner(target, port, timeout=2.0):
    """
    Grab service banner from a specific port
    
    Args:
        target (str): Target IP or hostname
        port (int): Port number
        timeout (float): Socket timeout in seconds
        
    Returns:
        dict: Banner information
    """
    banner = ""
    service_info = {'service': 'unknown', 'version': None}
    
    try:
        # Connect to the port
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((target, port))
        
        # Common protocol initiation strings
        probes = {
            21: b"",  # FTP - server sends banner on connect
            22: b"",  # SSH - server sends banner on connect
            23: b"",  # Telnet - server sends banner on connect
            25: b"EHLO security-scanner.local\r\n",  # SMTP
            80: b"HEAD / HTTP/1.1\r\nHost: " + target.encode() + b"\r\n\r\n",  # HTTP
            110: b"",  # POP3 - server sends banner on connect
            143: b"a1 CAPABILITY\r\n",  # IMAP
            443: b"",  # HTTPS - requires SSL/TLS wrapper
            3306: b"\x0a",  # MySQL
            5432: b"",  # PostgreSQL
        }
        
        # Send probe if available for the port
        if port in probes:
            if probes[port]:  # Only send if not empty string
                sock.send(probes[port])
        
        # Receive banner
        try:
            banner = sock.recv(1024)
            if isinstance(banner, bytes):
                banner = banner.decode('utf-8', errors='ignore')
        except socket.timeout:
            banner = ""
        
        # Identify service and version from banner
        service_info = identify_service(port, banner)
        
        sock.close()
        
    except socket.error as e:
        banner = f"Error: {str(e)}"
    except Exception as e:
        banner = f"Error: {str(e)}"
    
    return {
        'port': port,
        'banner': banner,
        'service': service_info['service'],
        'version': service_info['version'],
        'protocol': 'tcp'
    }
def grab_banners(target, ports, threads=10, timeout=2.0):
    """
    Grab banners from multiple open ports using multithreading
    
    Args:
        target (str): Target IP or hostname
        ports (list): List of open ports
        threads (int): Number of threads to use
        timeout (float): Socket timeout in seconds
        
    Returns:
        dict: Dictionary of port information including banners
    """
    logger.info(f"Grabbing banners from {len(ports)} open ports using {threads} threads")
    results = {}
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
        future_to_port = {
            executor.submit(grab_banner, target, port, timeout): port for port in ports
        }
        
        for future in concurrent.futures.as_completed(future_to_port):
            port = future_to_port[future]
            try:
                banner_info = future.result()
                results[port] = banner_info
            except Exception as e:
                logger.error(f"Error grabbing banner from port {port}: {e}")
                results[port] = {
                    'port': port,
                    'banner': f"Error: {str(e)}",
                    'service': 'unknown',
                    'version': None,
                    'protocol': 'tcp'
                }
    
    return results

if __name__ == "__main__":
    # Simple test when module is run directly
    import sys
    if len(sys.argv) > 1:
        target = sys.argv[1]
        if len(sys.argv) > 2:
            ports = [int(p) for p in sys.argv[2].split(',')]
        else:
            ports = [21, 22, 25, 80, 443, 3306, 8080]
        
        results = grab_banners(target, ports)
        for port, info in results.items():
            print(f"Port {port} ({info['service']}): {info['banner']}")
    else:
        print("Usage: python banner_grabber.py <target> [ports]")

#core/port_scanner.py
#!/usr/bin/env python3
"""
Port Scanner Module
Scans for open ports on a target using multithreading for faster results
"""

import socket
import threading
import queue
from concurrent.futures import ThreadPoolExecutor
from utils.logger import Logger

# Initialize logger
logger = Logger()

def check_port(target, port, timeout=1.0):
    """
    Check if a specific port is open on the target
    
    Args:
        target (str): Target IP or hostname
        port (int): Port number to check
        timeout (float): Socket timeout in seconds
        
    Returns:
        int or None: Port number if open, None if closed
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((target, port))
        sock.close()
        if result == 0:
            return port
        return None
    except socket.gaierror:
        logger.error(f"Hostname resolution failed for {target}")
        return None
    except socket.error:
        return None
    except Exception as e:
        logger.error(f"Error checking port {port}: {str(e)}")
        return None

def scan_ports(target, ports=None, threads=10, timeout=1.0):
    """
    Scan multiple ports on the target
    
    Args:
        target (str): Target IP or hostname
        ports (list): List of ports to scan
        threads (int): Number of threads to use
        timeout (float): Socket timeout in seconds
        
    Returns:
        list: List of open ports
    """
    if ports is None:
        # Default ports to scan
        ports = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445, 
                 993, 995, 1723, 3306, 3389, 5900, 8080, 8443]
    
    logger.info(f"Scanning {len(ports)} ports on {target} with {threads} threads")
    open_ports = []
    
    # Use ThreadPoolExecutor for cleaner thread management
    with ThreadPoolExecutor(max_workers=threads) as executor:
        # Submit all tasks
        future_to_port = {
            executor.submit(check_port, target, port, timeout): port for port in ports
        }
        
        # Process results as they complete
        for future in future_to_port:
            try:
                result = future.result()
                if result:
                    open_ports.append(result)
                    logger.success(f"Port {result} is open")
            except Exception as e:
                port = future_to_port[future]
                logger.error(f"Error scanning port {port}: {str(e)}")
    
    return sorted(open_ports)

def scan_port_range(target, start_port, end_port, threads=10, timeout=1.0):
    """
    Scan a range of ports on the target
    
    Args:
        target (str): Target IP or hostname
        start_port (int): Starting port number
        end_port (int): Ending port number
        threads (int): Number of threads to use
        timeout (float): Socket timeout in seconds
        
    Returns:
        list: List of open ports
    """
    ports = range(start_port, end_port + 1)
    return scan_ports(target, ports, threads, timeout)

# Alternative implementation using queue for very large port ranges
def scan_ports_queue(target, ports=None, threads=10, timeout=1.0):
    """
    Scan ports using a queue-based approach (better for very large port ranges)
    
    Args:
        target (str): Target IP or hostname
        ports (list): List of ports to scan
        threads (int): Number of threads to use
        timeout (float): Socket timeout in seconds
        
    Returns:
        list: List of open ports
    """
    if ports is None:
        ports = range(1, 1001)  # Default scan first 1000 ports
    
    # Create a queue of ports to scan
    port_queue = queue.Queue()
    for port in ports:
        port_queue.put(port)
    
    # Shared list for open ports (with lock for thread safety)
    open_ports = []
    lock = threading.Lock()
    
    def worker():
        while not port_queue.empty():
            try:
                port = port_queue.get(block=False)
                result = check_port(target, port, timeout)
                if result:
                    with lock:
                        open_ports.append(result)
                        logger.success(f"Port {result} is open")
                port_queue.task_done()
            except queue.Empty:
                break
            except Exception as e:
                logger.error(f"Worker error: {str(e)}")
                port_queue.task_done()
    
    # Create and start worker threads
    thread_list = []
    for _ in range(min(threads, len(ports))):
        t = threading.Thread(target=worker)
        t.daemon = True
        t.start()
        thread_list.append(t)
    
    # Wait for all threads to complete
    for t in thread_list:
        t.join()
    
    return sorted(open_ports)

if __name__ == "__main__":
    # Simple test when module is run directly
    import sys
    if len(sys.argv) > 1:
        target = sys.argv[1]
        results = scan_ports(target)
        print(f"Open ports on {target}: {results}")
    else:
        print("Usage: python port_scanner.py <target>")

#core/banner_grabber.py
import re
import logging
import concurrent.futures

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

def identify_service(port, banner):
    """
    Identify service and version based on banner and port
    
    Args:
        port (int): Port number
        banner (str): Service banner
        
    Returns:
        dict: Service and version information
    """
    result = {'service': 'unknown', 'version': None}
    
    # Common service patterns
    patterns = {
        'ssh': (r'SSH-(\d+\.\d+).*?', r'SSH-\d+\.\d+-([^\s]+)'),
        'http': (r'HTTP/(\d+\.\d+)', r'Server: ([^\r\n]+)'),
        'ftp': (r'FTP|FileZilla|ProFTPD|vsftpd', r'([^\s]+) FTP|ProFTPD ([^\s]+)|FileZilla Server ([^\s]+)|vsftpd ([^\s]+)'),
        'smtp': (r'SMTP|Postfix|Exim|Sendmail', r'([^\s]+) ESMTP|ESMTP ([^\s]+)|Postfix ([^\s]+)|Exim ([^\s]+)|Sendmail ([^\s]+)'),
        'mysql': (r'MySQL', r'MySQL v([^\s]+)'),
        'postgresql': (r'PostgreSQL', r'PostgreSQL ([^\s]+)'),
        'rdp': (r'RDP', None),
        'vnc': (r'VNC|RFB', r'RFB (\d+\.\d+)'),
        'telnet': (r'telnet', None)
    }
    
    # Default service based on common ports
    default_services = {
        21: 'ftp',
        22: 'ssh',
        23: 'telnet',
        25: 'smtp',
        53: 'dns',
        80: 'http',
        110: 'pop3',
        143: 'imap',
        443: 'https',
        445: 'smb',
        3306: 'mysql',
        3389: 'rdp',
        5432: 'postgresql',
        5900: 'vnc',
        6379: 'redis',
        8080: 'http-alt',
        8443: 'https-alt',
        9200: 'elasticsearch',
        27017: 'mongodb'
    }
    
    # First try to identify by banner
    for service, (service_pattern, version_pattern) in patterns.items():
        if service_pattern and re.search(service_pattern, banner, re.IGNORECASE):
            result['service'] = service
            if version_pattern:
                version_match = re.search(version_pattern, banner, re.IGNORECASE)
                if version_match:
                    # Use the first non-None group
                    for group in version_match.groups():
                        if group:
                            result['version'] = group
                            break
            break
    
    # If not identified, use default service based on port
    if result['service'] == 'unknown' and port in default_services:
        result['service'] = default_services[port]
    
    return result

def grab_banners(target, ports, threads=10, timeout=2.0):
    """
    Grab banners from multiple open ports using multithreading
    
    Args:
        target (str): Target IP or hostname
        ports (list): List of open ports
        threads (int): Number of threads to use
        timeout (float): Socket timeout in seconds
        
    Returns:
        dict: Dictionary of port information including banners
    """
    logger.info(f"Grabbing banners from {len(ports)} open ports using {threads} threads")
    results = {}
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
        future_to_port = {
            executor.submit(grab_banner, target, port, timeout): port for port in ports
        }
        
        for future in concurrent.futures.as_completed(future_to_port):
            port = future_to_port[future]
            try:
                banner_info = future.result()
                results[port] = banner_info
            except Exception as e:
                logger.error(f"Error grabbing banner from port {port}: {e}")
                results[port] = {
                    'port': port,
                    'banner': f"Error: {str(e)}",
                    'service': 'unknown',
                    'version': None,
                    'protocol': 'tcp'
                }
    
    return results

if __name__ == "__main__":
    # Simple test when module is run directly
    import sys
    if len(sys.argv) > 1:
        target = sys.argv[1]
        if len(sys.argv) > 2:
            ports = [int(p) for p in sys.argv[2].split(',')]
        else:
            ports = [21, 22, 25, 80, 443, 3306, 8080]
        
        results = grab_banners(target, ports)
        for port, info in results.items():
            print(f"Port {port} ({info['service']}): {info['banner']}")
    else:
        print("Usage: python banner_grabber.py <target> [ports]")

#core/cve_lookup.py
#core/cve_lookup.py
#!/usr/bin/env python3
"""
CVE Lookup Module
Maps service banners to known CVEs using local database
"""

import json
import re
import os
from datetime import datetime
from utils.logger import Logger

logger = Logger()

class CVELookup:
    def __init__(self, db_path=None):
        self.db_path = db_path or os.path.join('data', 'cve_database.json')
        self.cve_data = self.load_database()

    def load_database(self):
        """Load CVE database from JSON file"""
        try:
            if os.path.exists(self.db_path):
                with open(self.db_path, 'r') as f:
                    return json.load(f)
            else:
                logger.warning(f"CVE database not found at {self.db_path}")
                return {}
        except Exception as e:
            logger.error(f"Error loading CVE database: {str(e)}")
            return {}

    def search_cves(self, service, version):
        """Search for CVEs matching service and version"""
        matches = []
        
        if not service or not version:
            return matches

        try:
            # Normalize service name
            service = service.lower()
            
            # Search in database
            for cve_id, cve_info in self.cve_data.items():
                if service in cve_info.get('affected_products', []):
                    version_pattern = cve_info.get('version_pattern', '')
                    if version_pattern and re.search(version_pattern, version):
                        matches.append({
                            'cve_id': cve_id,
                            'description': cve_info.get('description', ''),
                            'cvss_score': cve_info.get('cvss_score', 0.0),
                            'references': cve_info.get('references', []),
                            'published_date': cve_info.get('published_date', '')
                        })

        except Exception as e:
            logger.error(f"Error searching CVEs: {str(e)}")

        return matches

def lookup(banners):
    """
    Look up CVEs for service banners
    
    Args:
        banners (dict): Dictionary of port numbers to banner information
        
    Returns:
        dict: Dictionary of ports to CVE matches
    """
    cve_lookup = CVELookup()
    results = {}
    
    for port, banner_info in banners.items():
        service = banner_info.get('service')
        version = banner_info.get('version')
        
        if service and version:
            matches = cve_lookup.search_cves(service, version)
            if matches:
                results[port] = matches
    
    return results

if __name__ == "__main__":
    # Test CVE lookup
    test_banners = {
        80: {'service': 'apache', 'version': '2.4.29'},
        22: {'service': 'openssh', 'version': '7.6p1'}
    }
    
    results = lookup(test_banners)
    for port, cves in results.items():
        print(f"\nPort {port}:")
        for cve in cves:
            print(f"  {cve['cve_id']} (CVSS: {cve['cvss_score']})")

#core/dir_bruteforce.py
#core/dir_bruteforce.py
#!/usr/bin/env python3
"""
Directory Bruteforce Module
Discovers hidden directories and files on web servers
"""

import requests
import threading
from concurrent.futures import ThreadPoolExecutor
from urllib.parse import urljoin
from utils.logger import Logger

logger = Logger()

class DirectoryBruteforcer:
    def __init__(self, url, wordlist=None, threads=10, timeout=10):
        self.url = url.rstrip('/')
        self.threads = threads
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        self.found_dirs = []
        self.lock = threading.Lock()
        
        # Load wordlist
        if wordlist:
            with open(wordlist, 'r') as f:
                self.wordlist = [line.strip() for line in f]
        else:
            # Default minimal wordlist
            self.wordlist = [
                'admin', 'wp-admin', 'administrator', 'login', 'wp-content',
                'upload', 'uploads', 'backup', 'backups', 'config', 'dashboard',
                'cms', 'test', 'dev', 'development', 'staging', 'prod',
                'api', 'v1', 'v2', 'docs', 'documentation', 'blog',
                'wp-includes', 'include', 'includes', 'tmp', 'temp',
                'images', 'img', 'css', 'js', 'javascript', 'static',
                'media', 'assets', 'downloads', 'download', 'file',
                'files', 'admin.php', 'index.php', 'info.php', 'phpinfo.php'
            ]

    def check_directory(self, path):
        """Check if a directory exists"""
        try:
            url = urljoin(self.url, path)
            resp = self.session.get(url, timeout=self.timeout, allow_redirects=False)
            
            if resp.status_code in [200, 301, 302, 403]:
                result = {
                    'url': url,
                    'status_code': resp.status_code,
                    'size': len(resp.content),
                    'redirect': resp.headers.get('location', '') if resp.status_code in [301, 302] else None
                }
                
                with self.lock:
                    self.found_dirs.append(result)
                    logger.success(f"Found: {url} ({resp.status_code})")
                
                return result
            
        except requests.exceptions.RequestException:
            pass
        except Exception as e:
            logger.error(f"Error checking {path}: {str(e)}")
        
        return None

    def bruteforce(self):
        """Start directory bruteforce"""
        logger.info(f"Starting directory bruteforce on {self.url} with {len(self.wordlist)} words")
        
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            executor.map(self.check_directory, self.wordlist)
        
        return self.found_dirs

def bruteforce(url, wordlist=None, threads=10, timeout=10):
    """Main function to initiate directory bruteforce"""
    bruteforcer = DirectoryBruteforcer(url, wordlist, threads, timeout)
    return bruteforcer.bruteforce()

if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        url = sys.argv[1]
        wordlist = sys.argv[2] if len(sys.argv) > 2 else None
        results = bruteforce(url, wordlist)
        for result in results:
            print(f"Found: {result['url']} ({result['status_code']})")
    else:
        print("Usage: python dir_bruteforce.py <url> [wordlist]")
#core/vuln_scanner.py
#core/vuln_scanner.py
#!/usr/bin/env python3
"""
Vulnerability Scanner Module
Checks for common vulnerabilities in network services
"""

import socket
import ssl
import re
from concurrent.futures import ThreadPoolExecutor
from utils.logger import Logger

logger = Logger()

class VulnerabilityScanner:
    def __init__(self, target, timeout=10):
        self.target = target
        self.timeout = timeout
        self.vulnerabilities = []

    def check_ssl_vulnerability(self, port):
        """Check for SSL/TLS vulnerabilities"""
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.target, port), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=self.target) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate expiration
                    if cert and 'notAfter' in cert:
                        expiry = ssl.cert_time_to_seconds(cert['notAfter'])
                        if expiry < ssl.cert_time_to_seconds():
                            self.vulnerabilities.append({
                                'port': port,
                                'type': 'SSL Certificate Expired',
                                'severity': 'High',
                                'details': f"Certificate expired on {cert['notAfter']}"
                            })
                    
                    # Check for weak protocols
                    protocols = ssock.shared_ciphers()
                    weak_protocols = ['SSLv2', 'SSLv3', 'TLSv1.0', 'TLSv1.1']
                    for protocol in weak_protocols:
                        if any(p[1].startswith(protocol) for p in protocols):
                            self.vulnerabilities.append({
                                'port': port,
                                'type': 'Weak SSL/TLS Protocol',
                                'severity': 'Medium',
                                'details': f"Supports {protocol}"
                            })
        
        except Exception as e:
            logger.debug(f"SSL check error on port {port}: {str(e)}")

    def check_default_credentials(self, port, service):
        """Check for default credentials"""
        default_creds = {
            'ftp': [('anonymous', 'anonymous'), ('admin', 'admin')],
            'ssh': [('root', 'root'), ('admin', 'admin')],
            'mysql': [('root', ''), ('root', 'root')],
            'postgresql': [('postgres', 'postgres')],
            'mongodb': [('admin', 'admin')]
        }
        
        if service in default_creds:
            for username, password in default_creds[service]:
                try:
                    # Implement service-specific authentication checks here
                    # This is a placeholder for demonstration
                    self.vulnerabilities.append({
                        'port': port,
                        'type': 'Default Credentials Check',
                        'severity': 'High',
                        'details': f"Service: {service}, Credentials: {username}:{password}"
                    })
                except Exception as e:
                    logger.debug(f"Credentials check error: {str(e)}")

    def check_known_vulnerabilities(self, port, banner):
        """Check for known vulnerabilities based on banner information"""
        vuln_patterns = {
            r'Apache/(2\.4\.[0-9]|2\.2\.[0-9])': 'Vulnerable Apache Version',
            r'OpenSSH_(3|4|5|6|7\.[0-5])': 'Vulnerable OpenSSH Version',
            r'ProFTPD 1\.[3]\.[0-4]': 'Vulnerable ProFTPD Version'
        }
        
        for pattern, vuln_type in vuln_patterns.items():
            if re.search(pattern, banner):
                self.vulnerabilities.append({
                    'port': port,
                    'type': vuln_type,
                    'severity': 'High',
                    'details': f"Vulnerable version detected in banner: {banner}"
                })

def scan_vulnerabilities(target, ports, banners, timeout=10):
    """
    Main vulnerability scanning function
    
    Args:
        target (str): Target IP or hostname
        ports (list): List of open ports
        banners (dict): Dictionary of service banners
        timeout (float): Timeout for connections
        
    Returns:
        list: List of discovered vulnerabilities
    """
    scanner = VulnerabilityScanner(target, timeout)
    
    # Check SSL/TLS vulnerabilities on HTTPS ports
    ssl_ports = [p for p in ports if p in [443, 8443] or 
                 'ssl' in banners.get(p, {}).get('service', '').lower()]
    
    with ThreadPoolExecutor(max_workers=5) as executor:
        executor.map(scanner.check_ssl_vulnerability, ssl_ports)
    
    # Check other vulnerabilities
    for port in ports:
        banner_info = banners.get(port, {})
        service = banner_info.get('service', '').lower()
        banner = banner_info.get('banner', '')
        
        scanner.check_default_credentials(port, service)
        scanner.check_known_vulnerabilities(port, banner)
    
    return scanner.vulnerabilities

if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        target = sys.argv[1]
        # Simple test with common ports
        test_ports = [80, 443, 22, 21]
        test_banners = {
            80: {'service': 'apache', 'banner': 'Apache/2.4.29'},
            443: {'service': 'https', 'banner': 'nginx/1.14.0'},
            22: {'service': 'ssh', 'banner': 'OpenSSH_7.6p1'},
            21: {'service': 'ftp', 'banner': 'ProFTPD 1.3.5'}
        }
        
        vulns = scan_vulnerabilities(target, test_ports, test_banners)
        for vuln in vulns:
            print(f"[{vuln['severity']}] {vuln['type']} on port {vuln['port']}")
            print(f"Details: {vuln['details']}\n")
    else:
        print("Usage: python vuln_scanner.py <target>")


#core/web_scanner.py
#core/web_scanner.py
#!/usr/bin/env python3
"""
Web Application Scanner Module
Checks for common web vulnerabilities including OWASP Top 10
"""

import requests
import re
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor
from utils.logger import Logger

logger = Logger()

class WebScanner:
    def __init__(self, url, timeout=10):
        self.url = url
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        self.findings = []

    def scan_xss(self, url, params):
        """Test for XSS vulnerabilities"""
        payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
        ]
        
        for param in params:
            for payload in payloads:
                try:
                    data = {param: payload}
                    resp = self.session.post(url, data=data, timeout=self.timeout)
                    if payload in resp.text:
                        self.findings.append({
                            'type': 'XSS',
                            'url': url,
                            'parameter': param,
                            'payload': payload,
                            'severity': 'High'
                        })
                except Exception as e:
                    logger.error(f"XSS scan error: {str(e)}")

    def scan_sqli(self, url, params):
        """Test for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "1' OR '1'='1",
            "1; SELECT * FROM users--",
        ]
        
        error_patterns = [
            'SQL syntax.*MySQL',
            'Warning.*mysql_.*',
            'PostgreSQL.*ERROR',
            'ORA-[0-9][0-9][0-9][0-9]',
        ]
        
        for param in params:
            for payload in payloads:
                try:
                    data = {param: payload}
                    resp = self.session.post(url, data=data, timeout=self.timeout)
                    
                    for pattern in error_patterns:
                        if re.search(pattern, resp.text, re.IGNORECASE):
                            self.findings.append({
                                'type': 'SQL Injection',
                                'url': url,
                                'parameter': param,
                                'payload': payload,
                                'severity': 'Critical'
                            })
                            break
                except Exception as e:
                    logger.error(f"SQLi scan error: {str(e)}")

    def check_security_headers(self, url):
        """Check for missing security headers"""
        try:
            resp = self.session.get(url, timeout=self.timeout)
            headers = resp.headers
            
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header',
                'X-XSS-Protection': 'Missing X-XSS-Protection header',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                'Strict-Transport-Security': 'Missing HSTS header',
                'Content-Security-Policy': 'Missing Content-Security-Policy header'
            }
            
            for header, message in security_headers.items():
                if header not in headers:
                    self.findings.append({
                        'type': 'Missing Security Header',
                        'url': url,
                        'detail': message,
                        'severity': 'Medium'
                    })
        except Exception as e:
            logger.error(f"Security header check error: {str(e)}")

    def scan(self):
        """Run all web security scans"""
        try:
            # Initial request to get forms and links
            resp = self.session.get(self.url, timeout=self.timeout)
            soup = BeautifulSoup(resp.text, 'html.parser')
            
            # Check security headers
            self.check_security_headers(self.url)
            
            # Scan forms
            forms = soup.find_all('form')
            for form in forms:
                action = urljoin(self.url, form.get('action', ''))
                params = [input.get('name') for input in form.find_all('input') if input.get('name')]
                
                self.scan_xss(action, params)
                self.scan_sqli(action, params)
            
            return self.findings
            
        except Exception as e:
            logger.error(f"Web scan error: {str(e)}")
            return []

def scan_web(url, timeout=10):
    """Main function to initiate web scanning"""
    scanner = WebScanner(url, timeout)
    return scanner.scan()

if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        url = sys.argv[1]
        findings = scan_web(url)
        for finding in findings:
            print(f"[{finding['severity']}] {finding['type']}: {finding['url']}")
    else:
        print("Usage: python web_scanner.py <url>")

#utils/config.py
#utils/config.py
#!/usr/bin/env python3
"""
Configuration Module
Handles scanner configuration and settings
"""

import os
import json
import yaml
from utils.logger import Logger

logger = Logger()

class Config:
    DEFAULT_CONFIG = {
        'scan': {
            'threads': 10,
            'timeout': 2.0,
            'ports': '1-1000',
            'default_wordlist': 'data/directories.txt'
        },
        'web': {
            'user_agent': 'Security Scanner/1.0',
            'follow_redirects': True,
            'max_depth': 3,
            'exclude_extensions': ['.jpg', '.jpeg', '.png', '.gif', '.css', '.js']
        },
        'reporting': {
            'output_dir': 'reports',
            'default_format': 'json'
        },
        'database': {
            'cve_path': 'data/cve_database.json',
            'update_interval': 7  # days
        }
    }

    def __init__(self, config_file=None):
        self.config_file = config_file or 'config.yaml'
        self.config = self.load_config()

    def load_config(self):
        """Load configuration from file or use defaults"""
        config = self.DEFAULT_CONFIG.copy()
        
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    if self.config_file.endswith('.yaml'):
                        file_config = yaml.safe_load(f)
                    else:
                        file_config = json.load(f)
                
                # Update default config with file values
                self._update_recursive(config, file_config)
                logger.info(f"Loaded configuration from {self.config_file}")
            else:
                logger.info("Using default configuration")
                self.save_config(config)  # Save defaults for future use
        except Exception as e:
            logger.error(f"Error loading configuration: {str(e)}")
        
        return config

    def _update_recursive(self, base, update):
        """Recursively update dictionary"""
        for key, value in update.items():
            if key in base and isinstance(base[key], dict) and isinstance(value, dict):
                self._update_recursive(base[key], value)
            else:
                base[key] = value

    def save_config(self, config=None):
        """Save configuration to file"""
        if config is None:
            config = self.config
            
        try:
            os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
            
            with open(self.config_file, 'w') as f:
                if self.config_file.endswith('.yaml'):
                    yaml.dump(config, f, default_flow_style=False)
                else:
                    json.dump(config, f, indent=4)
                    
            logger.info(f"Configuration saved to {self.config_file}")
        except Exception as e:
            logger.error(f"Error saving configuration: {str(e)}")

    def get(self, section, key=None):
        """Get configuration value"""
        try:
            if key is None:
                return self.config[section]
            return self.config[section][key]
        except KeyError:
            logger.error(f"Configuration key not found: {section}.{key}")
            return None

    def set(self, section, key, value):
        """Set configuration value"""
        try:
            if section not in self.config:
                self.config[section] = {}
            self.config[section][key] = value
            self.save_config()
            return True
        except Exception as e:
            logger.error(f"Error setting configuration: {str(e)}")
            return False

if __name__ == "__main__":
    # Test configuration
    config = Config()
    print("Scan threads:", config.get('scan', 'threads'))
    print("Web user agent:", config.get('web', 'user_agent'))
    
    # Test setting value
    config.set('scan', 'threads', 20)
    print("Updated scan threads:", config.get('scan', 'threads'))

#utils/logger.py
#utils/logger.py
#!/usr/bin/env python3
"""
Logger Module
Provides consistent logging functionality across the scanner
"""

import sys
import logging
from datetime import datetime
from threading import Lock

class Logger:
    # ANSI color codes
    COLORS = {
        'SUCCESS': '\033[92m',  # Green
        'INFO': '\033[94m',     # Blue
        'WARNING': '\033[93m',   # Yellow
        'ERROR': '\033[91m',    # Red
        'DEBUG': '\033[95m',    # Magenta
        'RESET': '\033[0m'      # Reset
    }
    
    def __init__(self, verbose=False):
        self.verbose = verbose
        self.lock = Lock()
        
        # Configure logging
        logging.basicConfig(
            level=logging.DEBUG if verbose else logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        # Create file handler
        self.log_file = f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        file_handler = logging.FileHandler(self.log_file)
        file_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        logging.getLogger().addHandler(file_handler)

    def _log(self, level, message, color):
        """Internal logging method"""
        with self.lock:
            timestamp = datetime.now().strftime('%H:%M:%S')
            colored_message = f"{color}[{level}] {message}{self.COLORS['RESET']}"
            plain_message = f"[{level}] {message}"
            
            # Print to console with colors
            print(f"[{timestamp}] {colored_message}")
            
            # Log to file without colors
            if level == 'SUCCESS':
                logging.info(plain_message)
            else:
                getattr(logging, level.lower())(plain_message)

    def success(self, message):
        """Log success message"""
        self._log('SUCCESS', message, self.COLORS['SUCCESS'])

    def info(self, message):
        """Log info message"""
        self._log('INFO', message, self.COLORS['INFO'])

    def warning(self, message):
        """Log warning message"""
        self._log('WARNING', message, self.COLORS['WARNING'])

    def error(self, message):
        """Log error message"""
        self._log('ERROR', message, self.COLORS['ERROR'])

    def debug(self, message):
        """Log debug message"""
        if self.verbose:
            self._log('DEBUG', message, self.COLORS['DEBUG'])

if __name__ == "__main__":
    # Test logger
    logger = Logger(verbose=True)
    logger.success("This is a success message")
    logger.info("This is an info message")
    logger.warning("This is a warning message")
    logger.error("This is an error message")
    logger.debug("This is a debug message")

#utils/report.py
#utils/report.py
#!/usr/bin/env python3
"""
Report Generation Module
Generates scan reports in various formats
"""

import json
import os
from datetime import datetime
from utils.logger import Logger

logger = Logger()

class ReportGenerator:
    def __init__(self, results, format='json'):
        self.results = results
        self.format = format.lower()
        self.timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')

    def generate_json(self):
        """Generate JSON report"""
        filename = f"scan_report_{self.timestamp}.json"
        
        try:
            with open(filename, 'w') as f:
                json.dump(self.results, f, indent=4)
            return filename
        except Exception as e:
            logger.error(f"Error generating JSON report: {str(e)}")
            return None

    def generate_html(self):
        """Generate HTML report"""
        filename = f"scan_report_{self.timestamp}.html"
        
        try:
            html = """
            <!DOCTYPE html>
            <html>
            <head>
                <title>Security Scan Report</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 20px; }
                    h1, h2 { color: #333; }
                    .section { margin: 20px 0; }
                    .finding { margin: 10px 0; padding: 10px; border: 1px solid #ddd; }
                    .high { border-left: 5px solid #ff4444; }
                    .medium { border-left: 5px solid #ffbb33; }
                    .low { border-left: 5px solid #00C851; }
                    .details { margin-left: 20px; }
                </style>
            </head>
            <body>
            """
            
            # Add header
            html += f"""
                <h1>Security Scan Report</h1>
                <p>Target: {self.results['target']}</p>
                <p>Scan Date: {self.results['timestamp']}</p>
            """
            
            # Add open ports section
            html += """
                <div class='section'>
                    <h2>Open Ports</h2>
            """
            for port in self.results['open_ports']:
                banner = self.results['service_banners'].get(port, {})
                html += f"""
                    <div class='finding'>
                        <h3>Port {port}</h3>
                        <div class='details'>
                            <p>Service: {banner.get('service', 'unknown')}</p>
                            <p>Version: {banner.get('version', 'unknown')}</p>
                            <p>Banner: {banner.get('banner', 'N/A')}</p>
                        </div>
                    </div>
                """
            
            # Add vulnerabilities section
            if self.results.get('vulnerabilities'):
                html += """
                    <div class='section'>
                        <h2>Vulnerabilities</h2>
                """
                for vuln in self.results['vulnerabilities']:
                    severity_class = vuln['severity'].lower()
                    html += f"""
                        <div class='finding {severity_class}'>
                            <h3>{vuln['type']}</h3>
                            <div class='details'>
                                <p>Severity: {vuln['severity']}</p>
                                <p>Port: {vuln['port']}</p>
                                <p>Details: {vuln['details']}</p>
                            </div>
                        </div>
                    """
            
            # Close HTML
            html += """
                </div>
            </body>
            </html>
            """
            
            with open(filename, 'w') as f:
                f.write(html)
            return filename
            
        except Exception as e:
            logger.error(f"Error generating HTML report: {str(e)}")
            return None

    def generate(self):
        """Generate report in specified format"""
        if self.format == 'json':
            return self.generate_json()
        elif self.format == 'html':
            return self.generate_html()
        else:
            logger.error(f"Unsupported report format: {self.format}")
            return None

def generate_report(results, format='json'):
    """Main function to generate scan report"""
    generator = ReportGenerator(results, format)
    filename = generator.generate()
    
    if filename:
        logger.success(f"Report generated: {filename}")
        return filename
    else:
        logger.error("Failed to generate report")
        return None

if __name__ == "__main__":
    # Test report generation
    test_results = {
        'target': 'example.com',
        'timestamp': datetime.now().isoformat(),
        'open_ports': [80, 443, 22],
        'service_banners': {
            80: {'service': 'http', 'version': '2.4.29', 'banner': 'Apache/2.4.29'},
            443: {'service': 'https', 'version': '1.14.0', 'banner': 'nginx/1.14.0'},
            22: {'service': 'ssh', 'version': '7.6p1', 'banner': 'OpenSSH_7.6p1'}
        },
        'vulnerabilities': [
            {
                'port': 80,
                'type': 'Vulnerable Apache Version',
                'severity': 'High',
                'details': 'Apache 2.4.29 has known vulnerabilities'
            }
        ]
    }
    
    generate_report(test_results, 'html')
    generate_report(test_results, 'json')

#requirements.txt
#requirements.txt
requests>=2.28.0
beautifulsoup4>=4.11.0
PyYAML>=6.0
python-nmap>=0.7.1
colorama>=0.4.6
urllib3>=2.0.0
cryptography>=40.0.0
python-dateutil>=2.8.2
#data/cve_database.json
{
  "CVE-2021-44228": {
    "description": "Apache Log4j2 Remote Code Execution (Log4Shell)",
    "affected_products": ["apache", "log4j", "java"],
    "version_pattern": "2\\.[0-9]\\.[0-9]",
    "cvss_score": 10.0,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2021-44228",
      "https://www.lunasec.io/docs/blog/log4j-zero-day/"
    ],
    "published_date": "2021-12-10",
    "remediation": "Upgrade to Log4j 2.15.0 or higher"
  },
  "CVE-2021-45046": {
    "description": "Apache Log4j2 Remote Code Execution (second variant)",
    "affected_products": ["apache", "log4j", "java"],
    "version_pattern": "2\\.[0-9]\\.[0-9]",
    "cvss_score": 9.0,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2021-45046"
    ],
    "published_date": "2021-12-14",
    "remediation": "Upgrade to Log4j 2.16.0 or higher"
  },
  "CVE-2023-23638": {
    "description": "OpenSSH Pre-Authentication DoS Vulnerability",
    "affected_products": ["openssh", "ssh"],
    "version_pattern": "9\\.2",
    "cvss_score": 7.5,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2023-23638"
    ],
    "published_date": "2023-02-03",
    "remediation": "Upgrade to OpenSSH 9.2p1 or higher"
  },
  "CVE-2022-22965": {
    "description": "Spring Framework RCE Vulnerability (Spring4Shell)",
    "affected_products": ["spring", "java", "apache"],
    "version_pattern": "5\\.3\\.[0-9]|5\\.2\\.[0-9]",
    "cvss_score": 9.8,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2022-22965"
    ],
    "published_date": "2022-03-31",
    "remediation": "Upgrade to Spring Framework 5.3.18+ or 5.2.20+"
  },
  "CVE-2023-41993": {
    "description": "WebKit Buffer Overflow Vulnerability",
    "affected_products": ["webkit", "safari", "apple"],
    "version_pattern": "16\\.[0-9]",
    "cvss_score": 8.8,
    "references": [
      "https://support.apple.com/en-us/HT213843"
    ],
    "published_date": "2023-09-11",
    "remediation": "Update to latest browser version"
  },
  "CVE-2023-23583": {
    "description": "Apache Struts 2 Remote Code Execution",
    "affected_products": ["apache", "struts"],
    "version_pattern": "2\\.[0-5]\\.[0-9]",
    "cvss_score": 9.8,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2023-23583"
    ],
    "published_date": "2023-10-16",
    "remediation": "Upgrade to Struts 2.5.33 or higher"
  },
  "CVE-2023-46604": {
    "description": "Apache ActiveMQ Remote Code Execution Vulnerability",
    "affected_products": ["apache", "activemq"],
    "version_pattern": "5\\.[0-9]+\\.[0-9]+",
    "cvss_score": 10.0,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2023-46604"
    ],
    "published_date": "2023-10-25",
    "remediation": "Upgrade to ActiveMQ 5.18.3, 5.17.6, or 5.16.7"
  },
  "CVE-2023-4863": {
    "description": "Heap Buffer Overflow in WebP in libwebp",
    "affected_products": ["webkit", "chrome", "firefox", "edge", "webp", "libwebp"],
    "version_pattern": "1\\.[0-2]\\.[0-4]",
    "cvss_score": 8.8,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2023-4863"
    ],
    "published_date": "2023-09-11",
    "remediation": "Update browsers and systems with latest patches"
  },
  "CVE-2022-44268": {
    "description": "ImageMagick Arbitrary File Read Vulnerability",
    "affected_products": ["imagemagick"],
    "version_pattern": "7\\.[0-1]\\.[0-9]",
    "cvss_score": 8.6,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2022-44268"
    ],
    "published_date": "2022-11-07",
    "remediation": "Upgrade to ImageMagick 7.1.0-51 or higher"
  },
  "CVE-2022-34305": {
    "description": "MongoDB Privilege Escalation via JavaScript execution",
    "affected_products": ["mongodb"],
    "version_pattern": "5\\.[0-2]",
    "cvss_score": 8.1,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2022-34305"
    ],
    "published_date": "2022-10-07",
    "remediation": "Upgrade to MongoDB 5.3 or higher"
  },
  "CVE-2023-28252": {
    "description": "Windows Common Log File System Driver Elevation of Privilege",
    "affected_products": ["windows"],
    "version_pattern": "10|11",
    "cvss_score": 7.8,
    "references": [
      "https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-28252"
    ],
    "published_date": "2023-04-11",
    "remediation": "Apply latest Windows security updates"
  },
  "CVE-2022-1292": {
    "description": "OpenSSL c_rehash script command injection",
    "affected_products": ["openssl"],
    "version_pattern": "3\\.0\\.[0-3]|1\\.1\\.[0-9]",
    "cvss_score": 8.1,
    "references": [
      "https://www.openssl.org/news/secadv/20220503.txt"
    ],
    "published_date": "2022-05-03",
    "remediation": "Upgrade to OpenSSL 3.0.3 or 1.1.1o or higher"
  },
  "CVE-2019-0708": {
    "description": "Remote Desktop Services Remote Code Execution (BlueKeep)",
    "affected_products": ["windows", "rdp"],
    "version_pattern": ".*",
    "cvss_score": 9.8,
    "references": [
      "https://msrc.microsoft.com/update-guide/vulnerability/CVE-2019-0708"
    ],
    "published_date": "2019-05-14",
    "remediation": "Apply Windows security updates, disable Remote Desktop if not needed"
  },
  "CVE-2017-5638": {
    "description": "Apache Struts 2 Remote Code Execution (Jakarta Multipart parser)",
    "affected_products": ["apache", "struts"],
    "version_pattern": "2\\.[3-5]\\.[0-9]",
    "cvss_score": 10.0,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2017-5638"
    ],
    "published_date": "2017-03-06",
    "remediation": "Upgrade to Struts 2.3.32 or 2.5.10.1 or higher"
  },
  "CVE-2021-34527": {
    "description": "Windows Print Spooler Remote Code Execution (PrintNightmare)",
    "affected_products": ["windows", "print spooler"],
    "version_pattern": ".*",
    "cvss_score": 8.8,
    "references": [
      "https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34527"
    ],
    "published_date": "2021-07-01",
    "remediation": "Apply Windows security updates, disable Print Spooler if not needed"
  },
  "CVE-2023-24880": {
    "description": "Windows Hyper-V Remote Code Execution Vulnerability",
    "affected_products": ["windows", "hyper-v"],
    "version_pattern": "10|11|server",
    "cvss_score": 8.5,
    "references": [
      "https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-24880"
    ],
    "published_date": "2023-04-11",
    "remediation": "Apply latest Windows security updates"
  },
  "CVE-2022-22954": {
    "description": "VMware Workspace ONE Access and Identity Manager Remote Code Execution",
    "affected_products": ["vmware", "workspace one", "identity manager"],
    "version_pattern": ".*",
    "cvss_score": 9.8,
    "references": [
      "https://www.vmware.com/security/advisories/VMSA-2022-0011.html"
    ],
    "published_date": "2022-04-06",
    "remediation": "Apply VMware security patches immediately"
  },
  "CVE-2022-27225": {
    "description": "MySQL Authentication Bypass Vulnerability",
    "affected_products": ["mysql"],
    "version_pattern": "5\\.[7-9]\\.[0-9]|8\\.[0-9]\\.[0-9]",
    "cvss_score": 7.5,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2022-27225"
    ],
    "published_date": "2022-04-26",
    "remediation": "Update to latest MySQL version"
  },
  "CVE-2022-40684": {
    "description": "Fortinet FortiOS, FortiProxy, and FortiSwitchManager Authentication Bypass",
    "affected_products": ["fortinet", "fortios", "fortiproxy"],
    "version_pattern": ".*",
    "cvss_score": 9.8,
    "references": [
      "https://www.fortiguard.com/psirt/FG-IR-22-377"
    ],
    "published_date": "2022-10-10",
    "remediation": "Apply Fortinet security updates immediately"
  },
  "CVE-2023-3676": {
    "description": "GitLab RCE via GitHub import webhook functionality",
    "affected_products": ["gitlab"],
    "version_pattern": "16\\.[0-1]\\.[0-9]",
    "cvss_score": 9.9,
    "references": [
      "https://about.gitlab.com/releases/2023/08/01/critical-security-release-gitlab-16-2-1-released/"
    ],
    "published_date": "2023-08-01",
    "remediation": "Upgrade to GitLab 16.2.1 or higher"
  },
  "CVE-2022-21449": {
    "description": "Java ECDSA Signature Validation (Psychic Signatures)",
    "affected_products": ["java", "jdk"],
    "version_pattern": "15|16|17|18",
    "cvss_score": 7.5,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2022-21449"
    ],
    "published_date": "2022-04-19",
    "remediation": "Update to JDK 15.0.4, 16.0.3, 17.0.3, or 18.0.1"
  },
  "CVE-2023-32784": {
    "description": "KeePass Memory Disclosure Vulnerability",
    "affected_products": ["keepass"],
    "version_pattern": "2\\.5[0-3]",
    "cvss_score": 6.8,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2023-32784"
    ],
    "published_date": "2023-05-22",
    "remediation": "Upgrade to KeePass 2.54 or higher"
  },
  "CVE-2021-3711": {
    "description": "OpenSSL SM2 Decryption Buffer Overflow",
    "affected_products": ["openssl"],
    "version_pattern": "1\\.1\\.1[a-k]",
    "cvss_score": 9.8,
    "references": [
      "https://www.openssl.org/news/secadv/20210824.txt"
    ],
    "published_date": "2021-08-24",
    "remediation": "Upgrade to OpenSSL 1.1.1l or higher"
  },
  "CVE-2023-21036": {
    "description": "Microsoft Exchange Server Elevation of Privilege Vulnerability",
    "affected_products": ["microsoft", "exchange"],
    "version_pattern": "2019|2016",
    "cvss_score": 8.8,
    "references": [
      "https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-21036"
    ],
    "published_date": "2023-01-10",
    "remediation": "Apply latest Exchange security updates"
  },
  "CVE-2023-22809": {
    "description": "Sudo Privilege Escalation Vulnerability",
    "affected_products": ["sudo", "linux"],
    "version_pattern": "1\\.9\\.[0-9]",
    "cvss_score": 7.8,
    "references": [
      "https://nvd.nist.gov/vuln/detail/CVE-2023-22809"
    ],
    "published_date": "2023-01-18",
    "remediation": "Update to sudo 1.9.12p2 or higher"
  }
}
#data/directories.txt
# Common directories, endpoints, and sensitive paths for security scanning

# Admin Panels and Dashboards
admin/
administrator/
admin.php
admin.html
admincp/
admins/
admin_area/
adm/
backend/
cpanel/
console/
control/
dashboard/
manage/
management/
panel/
webadmin/
sysadmin/
supervisor/

# CMS and Applications
wp-admin/
wp-content/
wp-includes/
wp-login.php
joomla/
administrator/index.php
drupal/
magento/
typo3/
phpMyAdmin/
phpmyadmin/
pma/
myadmin/
laravel/
symfony/
api/
graphql/
swagger/
redoc/
docs/

# Configuration and Setup
setup/
install/
configure/
config/
conf/
settings/
.env
.git/
.htaccess
.well-known/
backup/
backups/
bak/
old/
dev/
development/
staging/
test/
testing/
beta/
prod/
production/

# User-Related
login/
login.php
logout/
register/
signup/
account/
profile/
user/
users/
members/
member/
auth/
authentication/
password/
reset/
forgot/
recover/

# Common Application Paths
cgi-bin/
bin/
includes/
scripts/
js/
javascript/
css/
styles/
images/
img/
media/
static/
assets/
uploads/
upload/
files/
docs/
documents/
data/
downloads/
export/
import/
logs/
log/
temp/
tmp/
cache/

# API and Endpoints
api/v1/
api/v2/
api/v3/
rest/
soap/
graphql/
rpc/
services/
endpoints/
webhooks/
callbacks/
feed/
feeds/
rss/
atom/
sitemap.xml
robots.txt

# Database and Storage
database/
db/
mysql/
pgsql/
mssql/
oracle/
sqlite/
backup/
backups/
dump/
sql/
mongodb/
redis/
elastic/
solr/
cassandra/

# Framework-Specific
vendor/
node_modules/
bower_components/
components/
controllers/
models/
views/
templates/
themes/

# Security and Testing
phpinfo.php
test.php
info.php
probe.php
status
health
metrics
ping
debug/
trace/
monitoring/
stats/

# Common Vulnerabilities
server-status
server-info
.svn/
.git/
.env
.env.backup
.env.local
.env.development
.env.production
.htpasswd
web.config
wp-config.php
config.php
configuration.php
settings.php
database.yml
credentials.json
secrets.json
error_log
errors.log
debug.log
access.log
.DS_Store
Thumbs.db

# Cloud & DevOps
.aws/
.azure/
.gcp/
terraform/
cloudformation/
kubernetes/
k8s/
jenkins/
circleci/
gitlab-ci/
github/
bitbucket/

# Sensitive Directories
private/
secret/
confidential/
internal/
restricted/
secure/
hidden/
staff/
admin_only/
vault/

# File Extensions to Check (append to common paths)
index.php
index.html
index.jsp
index.asp
index.aspx
default.php
default.asp
default.aspx
web.config
readme.html
readme.txt
readme.md
license.txt
CHANGELOG.txt
CHANGELOG.md
config.ini
config.xml
error.log

# OWASP Top 10 Testing Paths
TRACE/
OPTIONS/
PUT/
DELETE/
shell.php
cmd.php
command.php
exec.php
system.php
eval.php
lfi.php
rfi.php
xxe.php
ssrf.php
idor.php
csrf.php
xss.php
sql.php
path-traversal.php
file-inclusion.php
file-upload.php
file-download.php
deserialization.php
#data/user_agents.txt
# A comprehensive collection of user agents for security scanning and web testing

# Modern Desktop Browsers
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15
Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0
Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0
Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/117.0
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.47
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.47

# Mobile Browsers
Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1
Mozilla/5.0 (iPhone; CPU iPhone OS 16_6_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1
Mozilla/5.0 (Linux; Android 13; SM-S901B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36
Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Mobile Safari/537.36
Mozilla/5.0 (Linux; Android 13; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36
Mozilla/5.0 (iPad; CPU OS 16_6_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1

# Older Browser Versions (for compatibility testing)
Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36
Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0
Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko
Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)

# Common Bots and Crawlers
Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)
Mozilla/5.0 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm)
Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)
Mozilla/5.0 (compatible; DuckDuckBot-Https/1.1; https://duckduckgo.com/duckduckbot)
Mozilla/5.0 (compatible; AhrefsBot/7.0; +http://ahrefs.com/robot/)
Twitterbot/1.0
facebookexternalhit/1.1
LinkedInBot/1.0

# Security Tools & Scanners
Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)
sqlmap/1.7.2#stable (http://sqlmap.org)
Nikto/2.1.6
Acunetix-Product/1 (https://www.acunetix.com/web-vulnerability-scanner/)
Mozilla/5.0 (compatible; OWASP WAVSEP/1.5; +https://github.com/sectooladdict/wavsep)
ZAP/2.13.0

# Feature Specific User Agents
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 (Headless)
Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/104.0.5112.101 Safari/537.36
Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Mobile Safari/537.36,gzip(gfe)
Mozilla/5.0 (Linux; Android 6.0.1; Nexus 5X Build/MMB29P) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.92 Mobile Safari/537.36 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)
Mozilla/5.0 (compatible; Google-AMPHTML/2.0; +http://www.google.com/bot.html)

# Security Scanner (Custom)
Advanced-Security-Scanner/1.0 (Security Scanning Tool)
Mozilla/5.0 (Security-Scanner; +http://example.com/security-scanner)
Mozilla/5.0 (Vulnerability-Scanner; Permissions-Policy-Test)

# IoT and Other Devices
Mozilla/5.0 (Linux; Android 12; SM-G780G) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Mobile Safari/537.36 NewsApp/3.8.4
Mozilla/5.0 (Nintendo Switch; WebApplet) AppleWebKit/609.4 (KHTML, like Gecko) NF/6.0.2.21.3 NintendoBrowser/5.1.0.21931
Mozilla/5.0 (PlayStation; PlayStation 5/2.26) AppleWebKit/605.1.15 (KHTML, like Gecko)
Mozilla/5.0 (Windows NT 10.0; Win64; x64; Xbox; Xbox One) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edge/44.18363.8131
Mozilla/5.0 (SmartTV; Linux; Tizen 2.4.0) AppleWebKit/538.1 (KHTML, like Gecko) Version/2.4.0 TV Safari/538.1

# API Testing
PostmanRuntime/7.33.0
curl/7.87.0
Wget/1.21.3
python-requests/2.31.0
okhttp/4.10.0

# Misc/Special Purpose
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) AppleWebKit/601.2.4 (KHTML, like Gecko) Version/9.0.1 Safari/601.2.4 facebookexternalhit/1.1 Facebot Twitterbot/1.0
WhatsApp/2.23.18.80 A
TikTok 26.5.1 rv:265101 (iPhone; iOS 17.0; en_US; Apple) Cronet
Amazon CloudFront